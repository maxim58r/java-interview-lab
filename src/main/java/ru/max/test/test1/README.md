# Задача: FixedCapacityMessagePool

Нужно реализовать пул сообщений фиксированной ёмкости с быстрым доступом:

* добавление в конец,
* извлечение самого старого (FIFO),
* извлечение случайного,
* удаление по `id` — всё за **O(1)** амортизированно.

## Модель

```java
public record Message(String id, long createdAt, String text) {}
```

* `id` — строковый уникальный идентификатор (можно UUID как строку).
* `createdAt` — epoch millis (или `Instant.toEpochMilli()`).
* `text` — произвольный контент.

## Требования к API

Реализовать класс:

```java
public final class FixedCapacityMessagePool {
    public FixedCapacityMessagePool(int capacity) { /* capacity > 0 */ }

    // Добавляет сообщение.
    // Если пул полон — автоматически удаляет самое старое сообщение и возвращает его; иначе возвращает null.
    public Message add(Message m);

    // Возвращает и удаляет самое старое (FIFO), либо null если пусто.
    public Message pollOldest();

    // Возвращает случайное сообщение из текущих без удаления, либо null если пусто. O(1).
    public Message random();

    // Удаляет сообщение по id за O(1). Возвращает удалённое сообщение или null если такого нет.
    public Message removeById(String id);

    public int size();
    public int capacity();
}
```

## Ограничения по сложности

* `add`, `pollOldest`, `random`, `removeById` — **O(1)** амортизированно.
* Допустимо внутреннее увеличение массива (амортизированная константа) для структур, **кроме** того что общая ёмкость пула фиксирована.

## Подсказки по структурам данных (можно игнорировать и сделать по-своему)

* Для **FIFO** храните «очередь» порядка поступления (например, `ArrayDeque<Message>`).
* Для **random O(1)** храните «мешок» в `ArrayList<Message>` + **Map** `id → index`.
* Для **removeById O(1)** используйте трюк **swap-with-last** в `ArrayList` и обновляйте индекс в Map.
* Когда `capacity` достигнута в `add` — сначала удалите **самое старое** и согласованно вычистите его из «мешка» и `Map`.

## Пример использования

```java
var pool = new FixedCapacityMessagePool(2);

pool.add(new Message("A", 1000L, "a")); // -> null
pool.add(new Message("B", 1001L, "b")); // -> null
var evicted = pool.add(new Message("C", 1002L, "c")); // -> вернёт Message("A", ...)
assert evicted.id().equals("A");
assert pool.size() == 2; // остались B и C

var oldest = pool.pollOldest(); // -> B
var rnd = pool.random();        // -> C (единственный)
var removed = pool.removeById("C"); // -> C
assert pool.size() == 0;
```

## Граничные случаи (должны быть покрыты тестами)

1. `capacity=1`: последовательные `add` должны каждый раз выселять предыдущий.
2. Пустой пул: `pollOldest()` и `random()` возвращают `null`.
3. `removeById` по несуществующему id — `null`, состояние не меняется.
4. Комбо-операции: `add` (с выселением) + сразу `removeById` выселенного не должны ломать структуры.
5. `random()` после множества `add/removeById/pollOldest` никогда не должен возвращать уже удалённые сообщения.
6. Удаление элемента, который находится в конце «мешка» — корректно, без лишних обменов.

## Набросок юнит-тестов (что проверить)

* FIFO-поведение `pollOldest`.
* Автовыселение при переполнении и корректное возвращаемое значение `add`.
* Равномерность `random()` хотя бы на базовом уровне (возвращает только существующие).
* `removeById` удаляет именно нужный элемент и не трогает остальные.
* Инвариант: `size()` согласован с фактическим количеством элементов (после длинной серии операций).

## Бонус-задания (по желанию)

* Сделать потокобезопасную версию с одним `ReentrantLock`.
* Добавить метод `peekOldest()` (без удаления) — O(1).
* Ввести TTL: метод `evictExpired(nowMillis)` удаляет все просроченные за O(k), где k — число удалённых, при этом остальные операции остаются O(1) амортизированно.
* Версия, где `id` может повторяться (мультисет): хранить `id → множество индексов`.

Хочешь — после того как набросаешь решение, пришли сюда: я пробегусь по корректности инвариантов, укажу на «тонкие места» и помогу довести до идеала.
